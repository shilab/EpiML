source('~/Experiment/ShiLab/EpiMap/script/lasso.R', echo=TRUE)
plot.glmnet()
source('~/Experiment/ShiLab/EpiMap/script/lasso.R', echo=TRUE)
View(fit1)
source('~/Experiment/ShiLab/EpiMap/script/lasso.R', echo=TRUE)
source('~/Experiment/ShiLab/EpiMap/script/lasso.R', echo=TRUE)
source('~/Experiment/ShiLab/EpiMap/script/lasso.R', echo=TRUE)
source('~/Experiment/ShiLab/EpiMap/script/lasso.R', echo=TRUE)
plot.glmnet(fit1,label = TRUE)
source('~/Experiment/ShiLab/EpiMap/script/lasso.R', echo=TRUE)
fit1$norm
fit1$lambda
fit1$dev
library('glmnet')
x=matrix(rnorm(100*20),100,20)
y=rnorm(100)
args<-commandArgs(trailingOnly = TRUE)
alpha<-args[1]
alpha<-1
X=args[3]
Y=args[4]
fit1=glmnet(x,y,alpha=alpha)
coef(fit1,s=0.01) # extract coefficients at a single value of lambda
plot.glmnet(fit1,label = TRUE)
fit1$dev
library('glmnet')
load("QuickStartExample.RData")
data(QuickStartExample)
data(QuickStartExample)
alpha<-1
fit1=glmnet(x,y,alpha=alpha)
fit=glmnet(x,y,alpha=alpha)
plot(fit)
print(fit)
data(QuickStartExample)
fit=glmnet(x,y,alpha=alpha)
plot(fit,label = TRUE)
coef(fit,s=0.1) # extract coefficients at a single value of lambda
nx = matrix(rnorm(10*20),10,20)
predict(fit,newx=nx,s=c(0.1,0.05))
cvfit = cv.glmnet(x, y)
plot(cvfit,label=TRUE)
cvfit = cv.glmnet(x, y)
plot(cvfit)
#cross validation
cvfit = cv.glmnet(x, y, alpha=1)
plot(cvfit)
cvfit$lambda.min
#cross validation
cvfit = cv.glmnet(x, y)
plot(cvfit)
cvfit$lambda.min
cvfit$cvm
workspace <- '/Users/jchen67/Experiment/ShiLab_securityCode/EpiMap/upload_data/userid_1/jobid_1'
x_filename <- 'bc_x.txt'
main_filename <- 'EBEN.main_result.txt'
epis_filename <- 'EBEN.epis_result.txt'
hyperparams_filename <- 'EBEN.blup_full_hyperparams.txt'
library('EBEN')
cat('EBEN_predict parameters:', '\n')
cat('\tworkspace:', workspace, '\n')
cat('\tmain_filename:', main_filename, '\n')
cat('\tepis_filename:', epis_filename, '\n')
cat('\tintercept_filename:', hyperparams_filename, '\n')
cat('read data', '\n')
x <- read.table(
file = file.path(workspace, x_filename),
header = TRUE,
check.names = FALSE,
row.names = 1
)
sprintf('x size: (%d, %d)', nrow(x), ncol(x))
main_effect <-
read.table(file = file.path(workspace, main_filename),
header = T,
sep = '\t',
check.names = FALSE)
sprintf('main_effect size: (%d, %d)',
nrow(main_effect),
ncol(main_effect))
epis_effect <-
read.table(file = file.path(workspace, epis_filename),
header = T,
sep = '\t',
check.names = FALSE)
sprintf('epis_effect size: (%d, %d)',
nrow(epis_effect),
ncol(epis_effect))
hyperparams <-
read.table(file = file.path(workspace, hyperparams_filename),
header = TRUE)
sprintf('hyperparams size: (%d, %d)', nrow(hyperparams), ncol(hyperparams))
intercept<-hyperparams$Intercept
x <- t(x)
x11 <- matrix(as.numeric(x), nrow(x))
cat('Filter the miRNA data with more than 20% missing data', '\n')
x1 <- NULL
x1_rownames <- NULL
for (i in 1:nrow(x11)) {
if (sum(as.numeric(x11[i, ]) != 0)) {
x1 <- rbind(x1, x[i, ])
x1_rownames <- c(x1_rownames, rownames(x)[i])
}
}
rownames(x1) <- x1_rownames
x2 <- NULL
x2_rownames <- NULL
criteria <- trunc((ncol(x1) - 1) * 0.8)
for (i in 1:nrow(x1)) {
if (sum(as.numeric(x1[i, (2:ncol(x1))]) != 0) > criteria) {
x2 <- rbind(x2, x1[i, ])
x2_rownames <- c(x2_rownames, x1_rownames[i])
}
}
rownames(x2) <- x2_rownames
colnames(x2) <- colnames(x)
cat('Quantile normalization', '\n')
x3 <- x2
for (sl in 1:nrow(x3)) {
mat = matrix(as.numeric(x3[sl, ]), 1)
mat = t(apply(mat, 1, rank, ties.method = "average"))
mat = qnorm(mat / (ncol(x3) + 1))
x3[sl, ] = mat
}
rm(sl, mat)
cat('predict based on main epistatic effects', '\n')
x3 <- t(x3)
y_main_predict = x3[, main_effect[, 1]] %*% matrix(main_effect[, 2], ncol = 1)
Epis_geno = x3[, epis_effect[, 1], drop = F] * x3[, epis_effect[, 2], drop = F]
y_epis_predict = Epis_geno %*% matrix(epis_effect[, 3], ncol = 1)
y_predict = intercept + y_main_predict + y_epis_predict
cat('Done!')
View(y_predict)
y_predict = intercept + y_main_predict + y_epis_predict
write.table(
y_predict,
file = file.path(workspace, 'EBEN_predict.txt'),
quote = F,
sep = '\t',
row.names = T,
)
y_predict = intercept + y_main_predict + y_epis_predict
write.table(
y_predict,
file = file.path(workspace, 'EBEN_predict.txt'),
quote = F,
sep = '\t',
row.names = T,
col.names = F
)
y_predict = intercept + y_main_predict + y_epis_predict
write.table(
y_predict,
file = file.path(workspace, 'EBEN_predict.txt'),
quote = F,
sep = '\t',
row.names = T,
col.names = c('Samples, Predict')
)
y_predict = intercept + y_main_predict + y_epis_predict
write.table(
y_predict,
file = file.path(workspace, 'EBEN_predict.txt'),
quote = F,
sep = '\t',
row.names = T,
col.names = c('Samples', 'Predict')
)
y_predict = intercept + y_main_predict + y_epis_predict
write.table(
y_predict,
file = file.path(workspace, 'EBEN_predict.txt'),
quote = F,
sep = '\t',
row.names = T,
col.names = c('Samples', 'Predict')
)
View(y_predict)
y_predict = intercept + y_main_predict + y_epis_predict
write.table(
y_predict,
file = file.path(workspace, 'EBEN_predict.txt'),
quote = F,
sep = '\t',
row.names = T,
col.names = c('Samples', 'Predict')
)
View(y_main_predict)
setDT(df,keep.rownames=TRUE)[]
y_predict$Samples<-rownames(y_predict)
library('EBEN')
workspace <- '~/Downloads/EBEN-epistasis-master-4/'
x_filename <- 'bc_x.txt'
y_filename <- 'bc_y.txt'
workspace <- '~/Downloads/EBEN-epistasis-master-4/'
x_filename <- 'bc_x.txt'
y_filename <- 'bc_y.txt'
nFolds <- 5
seed <- 28213
cat('EBEN_train parameters:', '\n')
cat('\tworkspace:', workspace, '\n')
cat('\tx_filename:', x_filename, '\n')
cat('\ty_filename:', y_filename, '\n')
cat('\tnFolds:', nFolds, '\n')
cat('\tseed:', seed, '\n')
set.seed(seed)
x <- read.table(
file = file.path(workspace, x_filename),
header = TRUE,
check.names=FALSE,
row.names = 1
)
sprintf('x size: (%d, %d)', nrow(x), ncol(x))
y <- read.table(
file = file.path(workspace, y_filename),
header = TRUE,
row.names = 1
)
sprintf('y size: (%d, %d)', nrow(y), ncol(y))
y <- as.matrix(y)
target1 <- log(as.numeric(y), base = exp(1))
cat('Transform pathological stages into natural log values', '\n')
x <- t(x)
x11 <- matrix(as.numeric(x), nrow(x))
cat('Filter the miRNA data with more than 20% missing data', '\n')
x1 <- NULL
x1_rownames<-NULL
for (i in 1:nrow(x11)) {
if (sum(as.numeric(x11[i, ]) != 0)) {
x1 <- rbind(x1, x[i, ])
x1_rownames<-c(x1_rownames,rownames(x)[i])
}
}
rownames(x1)<-x1_rownames
x2 <- NULL
x2_rownames<-NULL
criteria <- trunc((ncol(x1) - 1) * 0.8)
for (i in 1:nrow(x1)) {
if (sum(as.numeric(x1[i, (2:ncol(x1))]) != 0) > criteria) {
x2 <- rbind(x2, x1[i, ])
x2_rownames<-c(x2_rownames,x1_rownames[i])
}
}
rownames(x2)<-x2_rownames
colnames(x2) <- colnames(x)
cat('Quantile normalization', '\n')
x3 <- x2
for (sl in 1:nrow(x3)) {
mat = matrix(as.numeric(x3[sl, ]), 1)
mat = t(apply(mat, 1, rank, ties.method = "average"))
mat = qnorm(mat / (ncol(x3) + 1))
x3[sl, ] = mat
}
rm(sl, mat)
cat('Main effect estimated using EBEN', '\n')
x4 <- matrix(as.numeric(x3), nrow = nrow(x3))
CV = EBelasticNet.GaussianCV(t(x4), target1, nFolds = nFolds, Epis = "no")
Blup1 = EBelasticNet.Gaussian(
t(x4),
target1,
lambda = CV$Lambda_optimal,
alpha = CV$Alpha_optimal,
Epis = "no",
verbose = 0
)
Blup_main_sig = Blup1$weight[which(Blup1$weight[, 6] <= 0.05), ]
nFolds<-'5'
typeof(nFolds)
nFolds<-as.numeric(nFolds)
typeof(nFolds)
nFolds
nFolds<-'5'
nFolds<-as.integer(nFolds)
nFolds
typeof(nFolds)
library("BhGLM");
library("Matrix");
library("foreach");
library("glmnet");
source("cv.bh.R");
workspace <- '~/Downloads/new-pipline/'
x_filename <- 'Geno.txt'
y_filename <- 'Pheno.txt'
nFolds <- 5
seed <- 28213
cat('ssLasso parameters:', '\n')
cat('\tworkspace:', workspace, '\n')
cat('\tx_filename:', x_filename, '\n')
cat('\ty_filename:', y_filename, '\n')
cat('\tnFolds:', typeof(nFolds), '\n')
cat('\tseed:', seed, '\n')
set.seed(seed)
# read data
features <- read.table(
file = file.path(workspace, x_filename),
header = TRUE,
check.names = FALSE,
row.names = 1
)
sprintf('x size: (%d, %d)', nrow(x), ncol(x))
View(x)
# read data
features <- read.table(
file = file.path(workspace, x_filename),
header = TRUE,
check.names = FALSE,
row.names = 1
)
library("BhGLM");
library("Matrix");
library("foreach");
library("glmnet");
source("cv.bh.R");
workspace <- '~/Downloads/new-pipline/'
x_filename <- 'Geno.txt'
y_filename <- 'Pheno.txt'
nFolds <- 5
seed <- 28213
cat('ssLasso parameters:', '\n')
cat('\tworkspace:', workspace, '\n')
cat('\tx_filename:', x_filename, '\n')
cat('\ty_filename:', y_filename, '\n')
cat('\tnFolds:', typeof(nFolds), '\n')
cat('\tseed:', seed, '\n')
set.seed(seed)
# read data
features <- read.table(
file = file.path(workspace, x_filename),
header = TRUE,
check.names = FALSE,
row.names = 1
)
# read data
x <- read.table(
file = file.path(workspace, x_filename),
header = TRUE,
check.names = FALSE,
row.names = 1
)
sprintf('features size: (%d, %d)', nrow(x), ncol(x))
View(x)
y <- read.table(file = file.path(workspace, y_filename),
header = TRUE
);
sprintf('y size: (%d, %d)', nrow(y), ncol(y))
View(y)
write.table(
y,
file = file.path(workspace, 'aa.txt'),
quote = F,
sep = '\t',
row.names = T,
col.names = T
)
library("BhGLM");
library("Matrix");
library("foreach");
library("glmnet");
source("cv.bh.R");
workspace <- '~/Downloads/new-pipline/'
x_filename <- 'Geno.txt'
y_filename <- 'Pheno.txt'
nFolds <- 5
seed <- 28213
cat('ssLasso parameters:', '\n')
cat('\tworkspace:', workspace, '\n')
cat('\tx_filename:', x_filename, '\n')
cat('\ty_filename:', y_filename, '\n')
cat('\tnFolds:', typeof(nFolds), '\n')
cat('\tseed:', seed, '\n')
set.seed(seed)
# read data
x <- read.table(
file = file.path(workspace, x_filename),
header = TRUE,
check.names = FALSE,
row.names = 1
)
sprintf('features size: (%d, %d)', nrow(x), ncol(x))
y <- read.table(
file = file.path(workspace, y_filename),
header = TRUE,
row.names = 1
)
sprintf('y size: (%d, %d)', nrow(y), ncol(y))
features <- as.matrix(x);
pheno <- as.matrix(y);
geno_stand <- scale(features);
new_y <- scale(pheno);
new_y_in = new_y[,1,drop=F];
### Pre-specify s0 and s1:
s0 = 0.001;
s1 = 0.5;
###### Main effect-single locus:
sig_index = which(abs(t(new_y_in) %*% geno_stand/(nrow(geno_stand)-1)) > 0.20);
sig_main <- sig_index;
######Epistasis effect-single locus:
sig_epi_sum <- NULL;
for(k in 1:(ncol(features)-1)){
single_new = features[,k,drop=FALSE];
new=features[,(k+1):ncol(features)];
new_combine = cbind(new,single_new);
pseudo_allmat = transform(new_combine,subpseudo=new_combine[,1:(ncol(features)-k)] * new_combine[,ncol(new_combine)]);
pseudo_mat = pseudo_allmat[,grep("subpseudo",colnames(pseudo_allmat)),drop=FALSE];
pseudo_mat = as.matrix(pseudo_mat);
pseudo_mat_stand = scale(pseudo_mat);
####Save the ID for epistasis:
for(h in k:(ncol(features)-1)){
colnames(pseudo_mat)[h-k+1] = paste(k,"*",h+1,sep="");
}
epi_index = which(abs(t(new_y_in) %*% pseudo_mat_stand/(nrow(pseudo_mat_stand)-1)) > 0.20);
pseudo_mat_stand_epi = pseudo_mat[,epi_index,drop=FALSE];
sig_epi_sum = c(sig_epi_sum,colnames(pseudo_mat_stand_epi));
}
res <- matrix(c(sig_main,sig_epi_sum),ncol=1);
new_matrix <- NULL;
for(i in 1:nrow(res)){
if(length(grep("\\*",res[i,1])) == 0){
tmp1 = features[,(as.numeric(res[i,1])),drop=F];
colnames(tmp1) = res[i,1];
new_matrix <-cbind(new_matrix,tmp1);
}
if(length(grep("\\*",res[i,1])) == 1){
indexes = strsplit(res[i,1],"\\*");
tmp1 = features[,as.numeric(indexes[[1]][1]),drop=F] * features[,as.numeric(indexes[[1]][2]),drop=F];
colnames(tmp1) = res[i,1];
new_matrix <-cbind(new_matrix,tmp1);
}
}
new_matrix = as.matrix(new_matrix);
f2 = bmlasso(new_matrix, new_y_in, family = "gaussian", prior = "mde", ss = c(s0,s1),verbose = TRUE);
cv = cv.bh(f2,ncv=1,nfolds = 3,verbose = TRUE);
tmp_mse =  cv$measures["mse"];
tmp_dev = cv$measures["deviance"];
Blup = data.frame(f2$coefficients);
write.table(Blup,"Beta_estimates",quote = F,sep="\t",col.names = F,row.names = T)
